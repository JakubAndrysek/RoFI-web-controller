// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.3
//   protoc               v3.20.3
// source: src/protoc/rofi.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export enum ConnectorPosition {
  RETRACTED = 0,
  EXTENDED = 1,
  UNRECOGNIZED = -1,
}

export function connectorPositionFromJSON(object: any): ConnectorPosition {
  switch (object) {
    case 0:
    case "RETRACTED":
      return ConnectorPosition.RETRACTED;
    case 1:
    case "EXTENDED":
      return ConnectorPosition.EXTENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectorPosition.UNRECOGNIZED;
  }
}

export function connectorPositionToJSON(object: ConnectorPosition): string {
  switch (object) {
    case ConnectorPosition.RETRACTED:
      return "RETRACTED";
    case ConnectorPosition.EXTENDED:
      return "EXTENDED";
    case ConnectorPosition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConnectorOrientation {
  NORTH = 0,
  SOUTH = 1,
  EAST = 2,
  WEST = 3,
  UNRECOGNIZED = -1,
}

export function connectorOrientationFromJSON(object: any): ConnectorOrientation {
  switch (object) {
    case 0:
    case "NORTH":
      return ConnectorOrientation.NORTH;
    case 1:
    case "SOUTH":
      return ConnectorOrientation.SOUTH;
    case 2:
    case "EAST":
      return ConnectorOrientation.EAST;
    case 3:
    case "WEST":
      return ConnectorOrientation.WEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectorOrientation.UNRECOGNIZED;
  }
}

export function connectorOrientationToJSON(object: ConnectorOrientation): string {
  switch (object) {
    case ConnectorOrientation.NORTH:
      return "NORTH";
    case ConnectorOrientation.SOUTH:
      return "SOUTH";
    case ConnectorOrientation.EAST:
      return "EAST";
    case ConnectorOrientation.WEST:
      return "WEST";
    case ConnectorOrientation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConnectorLine {
  INTERNAL = 0,
  EXTERNAL = 1,
  UNRECOGNIZED = -1,
}

export function connectorLineFromJSON(object: any): ConnectorLine {
  switch (object) {
    case 0:
    case "INTERNAL":
      return ConnectorLine.INTERNAL;
    case 1:
    case "EXTERNAL":
      return ConnectorLine.EXTERNAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectorLine.UNRECOGNIZED;
  }
}

export function connectorLineToJSON(object: ConnectorLine): string {
  switch (object) {
    case ConnectorLine.INTERNAL:
      return "INTERNAL";
    case ConnectorLine.EXTERNAL:
      return "EXTERNAL";
    case ConnectorLine.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LidarDistanceMode {
  AUTONOMOUS = 0,
  SHORT = 1,
  LONG = 2,
  UNRECOGNIZED = -1,
}

export function lidarDistanceModeFromJSON(object: any): LidarDistanceMode {
  switch (object) {
    case 0:
    case "AUTONOMOUS":
      return LidarDistanceMode.AUTONOMOUS;
    case 1:
    case "SHORT":
      return LidarDistanceMode.SHORT;
    case 2:
    case "LONG":
      return LidarDistanceMode.LONG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LidarDistanceMode.UNRECOGNIZED;
  }
}

export function lidarDistanceModeToJSON(object: LidarDistanceMode): string {
  switch (object) {
    case LidarDistanceMode.AUTONOMOUS:
      return "AUTONOMOUS";
    case LidarDistanceMode.SHORT:
      return "SHORT";
    case LidarDistanceMode.LONG:
      return "LONG";
    case LidarDistanceMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LidarStatus {
  ERROR = 0,
  NOT_MEASURED = 1,
  OUTSIDE_RANGE = 2,
  VALID = 3,
  UNRECOGNIZED = -1,
}

export function lidarStatusFromJSON(object: any): LidarStatus {
  switch (object) {
    case 0:
    case "ERROR":
      return LidarStatus.ERROR;
    case 1:
    case "NOT_MEASURED":
      return LidarStatus.NOT_MEASURED;
    case 2:
    case "OUTSIDE_RANGE":
      return LidarStatus.OUTSIDE_RANGE;
    case 3:
    case "VALID":
      return LidarStatus.VALID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LidarStatus.UNRECOGNIZED;
  }
}

export function lidarStatusToJSON(object: LidarStatus): string {
  switch (object) {
    case LidarStatus.ERROR:
      return "ERROR";
    case LidarStatus.NOT_MEASURED:
      return "NOT_MEASURED";
    case LidarStatus.OUTSIDE_RANGE:
      return "OUTSIDE_RANGE";
    case LidarStatus.VALID:
      return "VALID";
    case LidarStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConnectorEvent {
  CONNECT = 0,
  DISCONNECTED = 1,
  POWER_CHANGED = 2,
  UNRECOGNIZED = -1,
}

export function connectorEventFromJSON(object: any): ConnectorEvent {
  switch (object) {
    case 0:
    case "CONNECT":
      return ConnectorEvent.CONNECT;
    case 1:
    case "DISCONNECTED":
      return ConnectorEvent.DISCONNECTED;
    case 2:
    case "POWER_CHANGED":
      return ConnectorEvent.POWER_CHANGED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectorEvent.UNRECOGNIZED;
  }
}

export function connectorEventToJSON(object: ConnectorEvent): string {
  switch (object) {
    case ConnectorEvent.CONNECT:
      return "CONNECT";
    case ConnectorEvent.DISCONNECTED:
      return "DISCONNECTED";
    case ConnectorEvent.POWER_CHANGED:
      return "POWER_CHANGED";
    case ConnectorEvent.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RofiStateType {
  STATE_SUCCESS = 0,
  STATE_ERROR = 1,
  UNRECOGNIZED = -1,
}

export function rofiStateTypeFromJSON(object: any): RofiStateType {
  switch (object) {
    case 0:
    case "STATE_SUCCESS":
      return RofiStateType.STATE_SUCCESS;
    case 1:
    case "STATE_ERROR":
      return RofiStateType.STATE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RofiStateType.UNRECOGNIZED;
  }
}

export function rofiStateTypeToJSON(object: RofiStateType): string {
  switch (object) {
    case RofiStateType.STATE_SUCCESS:
      return "STATE_SUCCESS";
    case RofiStateType.STATE_ERROR:
      return "STATE_ERROR";
    case RofiStateType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DeviceCommandType {
  REBOOT = 0,
  SET_ID = 1,
  UNRECOGNIZED = -1,
}

export function deviceCommandTypeFromJSON(object: any): DeviceCommandType {
  switch (object) {
    case 0:
    case "REBOOT":
      return DeviceCommandType.REBOOT;
    case 1:
    case "SET_ID":
      return DeviceCommandType.SET_ID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeviceCommandType.UNRECOGNIZED;
  }
}

export function deviceCommandTypeToJSON(object: DeviceCommandType): string {
  switch (object) {
    case DeviceCommandType.REBOOT:
      return "REBOOT";
    case DeviceCommandType.SET_ID:
      return "SET_ID";
    case DeviceCommandType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum JointCommandType {
  SET_JOINT_VELOCITY = 0,
  SET_JOINT_POSITION = 1,
  SET_JOINT_TORQUE = 2,
  UNRECOGNIZED = -1,
}

export function jointCommandTypeFromJSON(object: any): JointCommandType {
  switch (object) {
    case 0:
    case "SET_JOINT_VELOCITY":
      return JointCommandType.SET_JOINT_VELOCITY;
    case 1:
    case "SET_JOINT_POSITION":
      return JointCommandType.SET_JOINT_POSITION;
    case 2:
    case "SET_JOINT_TORQUE":
      return JointCommandType.SET_JOINT_TORQUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JointCommandType.UNRECOGNIZED;
  }
}

export function jointCommandTypeToJSON(object: JointCommandType): string {
  switch (object) {
    case JointCommandType.SET_JOINT_VELOCITY:
      return "SET_JOINT_VELOCITY";
    case JointCommandType.SET_JOINT_POSITION:
      return "SET_JOINT_POSITION";
    case JointCommandType.SET_JOINT_TORQUE:
      return "SET_JOINT_TORQUE";
    case JointCommandType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConnectorCommandType {
  SET_CONNECT = 0,
  SET_DISCONNECT = 1,
  CONNECT_POWER = 2,
  DISCONNECT_POWER = 3,
  SET_DISTANCE_MODE = 4,
  UNRECOGNIZED = -1,
}

export function connectorCommandTypeFromJSON(object: any): ConnectorCommandType {
  switch (object) {
    case 0:
    case "SET_CONNECT":
      return ConnectorCommandType.SET_CONNECT;
    case 1:
    case "SET_DISCONNECT":
      return ConnectorCommandType.SET_DISCONNECT;
    case 2:
    case "CONNECT_POWER":
      return ConnectorCommandType.CONNECT_POWER;
    case 3:
    case "DISCONNECT_POWER":
      return ConnectorCommandType.DISCONNECT_POWER;
    case 4:
    case "SET_DISTANCE_MODE":
      return ConnectorCommandType.SET_DISTANCE_MODE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectorCommandType.UNRECOGNIZED;
  }
}

export function connectorCommandTypeToJSON(object: ConnectorCommandType): string {
  switch (object) {
    case ConnectorCommandType.SET_CONNECT:
      return "SET_CONNECT";
    case ConnectorCommandType.SET_DISCONNECT:
      return "SET_DISCONNECT";
    case ConnectorCommandType.CONNECT_POWER:
      return "CONNECT_POWER";
    case ConnectorCommandType.DISCONNECT_POWER:
      return "DISCONNECT_POWER";
    case ConnectorCommandType.SET_DISTANCE_MODE:
      return "SET_DISTANCE_MODE";
    case ConnectorCommandType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CommandTypeRequest {
  MESSAGE = 0,
  DEVICE = 1,
  JOINT = 2,
  CONNECTOR = 3,
  UNRECOGNIZED = -1,
}

export function commandTypeRequestFromJSON(object: any): CommandTypeRequest {
  switch (object) {
    case 0:
    case "MESSAGE":
      return CommandTypeRequest.MESSAGE;
    case 1:
    case "DEVICE":
      return CommandTypeRequest.DEVICE;
    case 2:
    case "JOINT":
      return CommandTypeRequest.JOINT;
    case 3:
    case "CONNECTOR":
      return CommandTypeRequest.CONNECTOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommandTypeRequest.UNRECOGNIZED;
  }
}

export function commandTypeRequestToJSON(object: CommandTypeRequest): string {
  switch (object) {
    case CommandTypeRequest.MESSAGE:
      return "MESSAGE";
    case CommandTypeRequest.DEVICE:
      return "DEVICE";
    case CommandTypeRequest.JOINT:
      return "JOINT";
    case CommandTypeRequest.CONNECTOR:
      return "CONNECTOR";
    case CommandTypeRequest.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Empty {
}

export interface Descriptor {
  countJoint: number;
  countConnector: number;
}

export interface Joint {
  maxPosition: number;
  minPosition: number;
  maxSpeed: number;
  minSpeed: number;
  maxTorque: number;
  velocity: number;
  position: number;
  torque: number;
}

export interface Connector {
  position: ConnectorPosition;
  internal: boolean;
  external: boolean;
  distanceMode: LidarDistanceMode;
  connected: boolean;
  orientation: ConnectorOrientation;
  internalVoltage: number;
  internalCurrent: number;
  externalVoltage: number;
  externalCurrent: number;
  lidarStatus: LidarStatus;
  distance: number;
}

export interface RofiStateData {
  randomNumber: number;
  descriptor: Descriptor | undefined;
  joints: Joint[];
  connectors: Connector[];
}

export interface RofiState {
  packetId: number;
  rofiId: number;
  type: RofiStateType;
  stateData?: RofiStateData | undefined;
  errorMessage?: string | undefined;
}

export interface DeviceCommand {
  command: DeviceCommandType;
  setId?: number | undefined;
}

export interface JointSetPosition {
  position: number;
  velocity: number;
}

export interface JointCommand {
  jointId: number;
  command: JointCommandType;
  setVelocity?: number | undefined;
  setPosition?: JointSetPosition | undefined;
  setTorque?: number | undefined;
}

export interface ConnectorCommand {
  connectorId: number;
  command: ConnectorCommandType;
  connectPower?: ConnectorLine | undefined;
  disconnectPower?: ConnectorLine | undefined;
  setDistanceMode?: LidarDistanceMode | undefined;
}

export interface Message {
  message: string;
}

/** Request is sent from the client to the RoFI */
export interface RofiRequest {
  packetId: number;
  command: CommandTypeRequest;
  message?: Message | undefined;
  device?: DeviceCommand | undefined;
  joint?: JointCommand | undefined;
  connector?: ConnectorCommand | undefined;
}

/** Response is sent from the RoFI to the client */
export interface RofiResponse {
  packetId: number;
  success: number;
  message: string;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseDescriptor(): Descriptor {
  return { countJoint: 0, countConnector: 0 };
}

export const Descriptor = {
  encode(message: Descriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countJoint !== 0) {
      writer.uint32(8).uint32(message.countJoint);
    }
    if (message.countConnector !== 0) {
      writer.uint32(16).uint32(message.countConnector);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Descriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.countJoint = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.countConnector = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Descriptor {
    return {
      countJoint: isSet(object.countJoint) ? globalThis.Number(object.countJoint) : 0,
      countConnector: isSet(object.countConnector) ? globalThis.Number(object.countConnector) : 0,
    };
  },

  toJSON(message: Descriptor): unknown {
    const obj: any = {};
    if (message.countJoint !== 0) {
      obj.countJoint = Math.round(message.countJoint);
    }
    if (message.countConnector !== 0) {
      obj.countConnector = Math.round(message.countConnector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Descriptor>, I>>(base?: I): Descriptor {
    return Descriptor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Descriptor>, I>>(object: I): Descriptor {
    const message = createBaseDescriptor();
    message.countJoint = object.countJoint ?? 0;
    message.countConnector = object.countConnector ?? 0;
    return message;
  },
};

function createBaseJoint(): Joint {
  return {
    maxPosition: 0,
    minPosition: 0,
    maxSpeed: 0,
    minSpeed: 0,
    maxTorque: 0,
    velocity: 0,
    position: 0,
    torque: 0,
  };
}

export const Joint = {
  encode(message: Joint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxPosition !== 0) {
      writer.uint32(13).float(message.maxPosition);
    }
    if (message.minPosition !== 0) {
      writer.uint32(21).float(message.minPosition);
    }
    if (message.maxSpeed !== 0) {
      writer.uint32(29).float(message.maxSpeed);
    }
    if (message.minSpeed !== 0) {
      writer.uint32(37).float(message.minSpeed);
    }
    if (message.maxTorque !== 0) {
      writer.uint32(45).float(message.maxTorque);
    }
    if (message.velocity !== 0) {
      writer.uint32(53).float(message.velocity);
    }
    if (message.position !== 0) {
      writer.uint32(61).float(message.position);
    }
    if (message.torque !== 0) {
      writer.uint32(69).float(message.torque);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Joint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.maxPosition = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.minPosition = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.maxSpeed = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.minSpeed = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.maxTorque = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.velocity = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.position = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.torque = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Joint {
    return {
      maxPosition: isSet(object.maxPosition) ? globalThis.Number(object.maxPosition) : 0,
      minPosition: isSet(object.minPosition) ? globalThis.Number(object.minPosition) : 0,
      maxSpeed: isSet(object.maxSpeed) ? globalThis.Number(object.maxSpeed) : 0,
      minSpeed: isSet(object.minSpeed) ? globalThis.Number(object.minSpeed) : 0,
      maxTorque: isSet(object.maxTorque) ? globalThis.Number(object.maxTorque) : 0,
      velocity: isSet(object.velocity) ? globalThis.Number(object.velocity) : 0,
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
      torque: isSet(object.torque) ? globalThis.Number(object.torque) : 0,
    };
  },

  toJSON(message: Joint): unknown {
    const obj: any = {};
    if (message.maxPosition !== 0) {
      obj.maxPosition = message.maxPosition;
    }
    if (message.minPosition !== 0) {
      obj.minPosition = message.minPosition;
    }
    if (message.maxSpeed !== 0) {
      obj.maxSpeed = message.maxSpeed;
    }
    if (message.minSpeed !== 0) {
      obj.minSpeed = message.minSpeed;
    }
    if (message.maxTorque !== 0) {
      obj.maxTorque = message.maxTorque;
    }
    if (message.velocity !== 0) {
      obj.velocity = message.velocity;
    }
    if (message.position !== 0) {
      obj.position = message.position;
    }
    if (message.torque !== 0) {
      obj.torque = message.torque;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Joint>, I>>(base?: I): Joint {
    return Joint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Joint>, I>>(object: I): Joint {
    const message = createBaseJoint();
    message.maxPosition = object.maxPosition ?? 0;
    message.minPosition = object.minPosition ?? 0;
    message.maxSpeed = object.maxSpeed ?? 0;
    message.minSpeed = object.minSpeed ?? 0;
    message.maxTorque = object.maxTorque ?? 0;
    message.velocity = object.velocity ?? 0;
    message.position = object.position ?? 0;
    message.torque = object.torque ?? 0;
    return message;
  },
};

function createBaseConnector(): Connector {
  return {
    position: 0,
    internal: false,
    external: false,
    distanceMode: 0,
    connected: false,
    orientation: 0,
    internalVoltage: 0,
    internalCurrent: 0,
    externalVoltage: 0,
    externalCurrent: 0,
    lidarStatus: 0,
    distance: 0,
  };
}

export const Connector = {
  encode(message: Connector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== 0) {
      writer.uint32(8).int32(message.position);
    }
    if (message.internal !== false) {
      writer.uint32(16).bool(message.internal);
    }
    if (message.external !== false) {
      writer.uint32(24).bool(message.external);
    }
    if (message.distanceMode !== 0) {
      writer.uint32(32).int32(message.distanceMode);
    }
    if (message.connected !== false) {
      writer.uint32(40).bool(message.connected);
    }
    if (message.orientation !== 0) {
      writer.uint32(48).int32(message.orientation);
    }
    if (message.internalVoltage !== 0) {
      writer.uint32(61).float(message.internalVoltage);
    }
    if (message.internalCurrent !== 0) {
      writer.uint32(69).float(message.internalCurrent);
    }
    if (message.externalVoltage !== 0) {
      writer.uint32(77).float(message.externalVoltage);
    }
    if (message.externalCurrent !== 0) {
      writer.uint32(85).float(message.externalCurrent);
    }
    if (message.lidarStatus !== 0) {
      writer.uint32(88).int32(message.lidarStatus);
    }
    if (message.distance !== 0) {
      writer.uint32(96).uint32(message.distance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.position = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.internal = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.external = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.distanceMode = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.connected = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.orientation = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.internalVoltage = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.internalCurrent = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.externalVoltage = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.externalCurrent = reader.float();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.lidarStatus = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.distance = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connector {
    return {
      position: isSet(object.position) ? connectorPositionFromJSON(object.position) : 0,
      internal: isSet(object.internal) ? globalThis.Boolean(object.internal) : false,
      external: isSet(object.external) ? globalThis.Boolean(object.external) : false,
      distanceMode: isSet(object.distanceMode) ? lidarDistanceModeFromJSON(object.distanceMode) : 0,
      connected: isSet(object.connected) ? globalThis.Boolean(object.connected) : false,
      orientation: isSet(object.orientation) ? connectorOrientationFromJSON(object.orientation) : 0,
      internalVoltage: isSet(object.internalVoltage) ? globalThis.Number(object.internalVoltage) : 0,
      internalCurrent: isSet(object.internalCurrent) ? globalThis.Number(object.internalCurrent) : 0,
      externalVoltage: isSet(object.externalVoltage) ? globalThis.Number(object.externalVoltage) : 0,
      externalCurrent: isSet(object.externalCurrent) ? globalThis.Number(object.externalCurrent) : 0,
      lidarStatus: isSet(object.lidarStatus) ? lidarStatusFromJSON(object.lidarStatus) : 0,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
    };
  },

  toJSON(message: Connector): unknown {
    const obj: any = {};
    if (message.position !== 0) {
      obj.position = connectorPositionToJSON(message.position);
    }
    if (message.internal !== false) {
      obj.internal = message.internal;
    }
    if (message.external !== false) {
      obj.external = message.external;
    }
    if (message.distanceMode !== 0) {
      obj.distanceMode = lidarDistanceModeToJSON(message.distanceMode);
    }
    if (message.connected !== false) {
      obj.connected = message.connected;
    }
    if (message.orientation !== 0) {
      obj.orientation = connectorOrientationToJSON(message.orientation);
    }
    if (message.internalVoltage !== 0) {
      obj.internalVoltage = message.internalVoltage;
    }
    if (message.internalCurrent !== 0) {
      obj.internalCurrent = message.internalCurrent;
    }
    if (message.externalVoltage !== 0) {
      obj.externalVoltage = message.externalVoltage;
    }
    if (message.externalCurrent !== 0) {
      obj.externalCurrent = message.externalCurrent;
    }
    if (message.lidarStatus !== 0) {
      obj.lidarStatus = lidarStatusToJSON(message.lidarStatus);
    }
    if (message.distance !== 0) {
      obj.distance = Math.round(message.distance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Connector>, I>>(base?: I): Connector {
    return Connector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Connector>, I>>(object: I): Connector {
    const message = createBaseConnector();
    message.position = object.position ?? 0;
    message.internal = object.internal ?? false;
    message.external = object.external ?? false;
    message.distanceMode = object.distanceMode ?? 0;
    message.connected = object.connected ?? false;
    message.orientation = object.orientation ?? 0;
    message.internalVoltage = object.internalVoltage ?? 0;
    message.internalCurrent = object.internalCurrent ?? 0;
    message.externalVoltage = object.externalVoltage ?? 0;
    message.externalCurrent = object.externalCurrent ?? 0;
    message.lidarStatus = object.lidarStatus ?? 0;
    message.distance = object.distance ?? 0;
    return message;
  },
};

function createBaseRofiStateData(): RofiStateData {
  return { randomNumber: 0, descriptor: undefined, joints: [], connectors: [] };
}

export const RofiStateData = {
  encode(message: RofiStateData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.randomNumber !== 0) {
      writer.uint32(8).int32(message.randomNumber);
    }
    if (message.descriptor !== undefined) {
      Descriptor.encode(message.descriptor, writer.uint32(18).fork()).join();
    }
    for (const v of message.joints) {
      Joint.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.connectors) {
      Connector.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RofiStateData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRofiStateData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.randomNumber = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.descriptor = Descriptor.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.joints.push(Joint.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.connectors.push(Connector.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RofiStateData {
    return {
      randomNumber: isSet(object.randomNumber) ? globalThis.Number(object.randomNumber) : 0,
      descriptor: isSet(object.descriptor) ? Descriptor.fromJSON(object.descriptor) : undefined,
      joints: globalThis.Array.isArray(object?.joints) ? object.joints.map((e: any) => Joint.fromJSON(e)) : [],
      connectors: globalThis.Array.isArray(object?.connectors)
        ? object.connectors.map((e: any) => Connector.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RofiStateData): unknown {
    const obj: any = {};
    if (message.randomNumber !== 0) {
      obj.randomNumber = Math.round(message.randomNumber);
    }
    if (message.descriptor !== undefined) {
      obj.descriptor = Descriptor.toJSON(message.descriptor);
    }
    if (message.joints?.length) {
      obj.joints = message.joints.map((e) => Joint.toJSON(e));
    }
    if (message.connectors?.length) {
      obj.connectors = message.connectors.map((e) => Connector.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RofiStateData>, I>>(base?: I): RofiStateData {
    return RofiStateData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RofiStateData>, I>>(object: I): RofiStateData {
    const message = createBaseRofiStateData();
    message.randomNumber = object.randomNumber ?? 0;
    message.descriptor = (object.descriptor !== undefined && object.descriptor !== null)
      ? Descriptor.fromPartial(object.descriptor)
      : undefined;
    message.joints = object.joints?.map((e) => Joint.fromPartial(e)) || [];
    message.connectors = object.connectors?.map((e) => Connector.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRofiState(): RofiState {
  return { packetId: 0, rofiId: 0, type: 0, stateData: undefined, errorMessage: undefined };
}

export const RofiState = {
  encode(message: RofiState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packetId !== 0) {
      writer.uint32(8).uint32(message.packetId);
    }
    if (message.rofiId !== 0) {
      writer.uint32(16).int32(message.rofiId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.stateData !== undefined) {
      RofiStateData.encode(message.stateData, writer.uint32(34).fork()).join();
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RofiState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRofiState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.packetId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.rofiId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stateData = RofiStateData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RofiState {
    return {
      packetId: isSet(object.packetId) ? globalThis.Number(object.packetId) : 0,
      rofiId: isSet(object.rofiId) ? globalThis.Number(object.rofiId) : 0,
      type: isSet(object.type) ? rofiStateTypeFromJSON(object.type) : 0,
      stateData: isSet(object.stateData) ? RofiStateData.fromJSON(object.stateData) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: RofiState): unknown {
    const obj: any = {};
    if (message.packetId !== 0) {
      obj.packetId = Math.round(message.packetId);
    }
    if (message.rofiId !== 0) {
      obj.rofiId = Math.round(message.rofiId);
    }
    if (message.type !== 0) {
      obj.type = rofiStateTypeToJSON(message.type);
    }
    if (message.stateData !== undefined) {
      obj.stateData = RofiStateData.toJSON(message.stateData);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RofiState>, I>>(base?: I): RofiState {
    return RofiState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RofiState>, I>>(object: I): RofiState {
    const message = createBaseRofiState();
    message.packetId = object.packetId ?? 0;
    message.rofiId = object.rofiId ?? 0;
    message.type = object.type ?? 0;
    message.stateData = (object.stateData !== undefined && object.stateData !== null)
      ? RofiStateData.fromPartial(object.stateData)
      : undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseDeviceCommand(): DeviceCommand {
  return { command: 0, setId: undefined };
}

export const DeviceCommand = {
  encode(message: DeviceCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== 0) {
      writer.uint32(8).int32(message.command);
    }
    if (message.setId !== undefined) {
      writer.uint32(16).int32(message.setId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.setId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceCommand {
    return {
      command: isSet(object.command) ? deviceCommandTypeFromJSON(object.command) : 0,
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : undefined,
    };
  },

  toJSON(message: DeviceCommand): unknown {
    const obj: any = {};
    if (message.command !== 0) {
      obj.command = deviceCommandTypeToJSON(message.command);
    }
    if (message.setId !== undefined) {
      obj.setId = Math.round(message.setId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeviceCommand>, I>>(base?: I): DeviceCommand {
    return DeviceCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeviceCommand>, I>>(object: I): DeviceCommand {
    const message = createBaseDeviceCommand();
    message.command = object.command ?? 0;
    message.setId = object.setId ?? undefined;
    return message;
  },
};

function createBaseJointSetPosition(): JointSetPosition {
  return { position: 0, velocity: 0 };
}

export const JointSetPosition = {
  encode(message: JointSetPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== 0) {
      writer.uint32(13).float(message.position);
    }
    if (message.velocity !== 0) {
      writer.uint32(21).float(message.velocity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JointSetPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJointSetPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.position = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.velocity = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JointSetPosition {
    return {
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
      velocity: isSet(object.velocity) ? globalThis.Number(object.velocity) : 0,
    };
  },

  toJSON(message: JointSetPosition): unknown {
    const obj: any = {};
    if (message.position !== 0) {
      obj.position = message.position;
    }
    if (message.velocity !== 0) {
      obj.velocity = message.velocity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JointSetPosition>, I>>(base?: I): JointSetPosition {
    return JointSetPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JointSetPosition>, I>>(object: I): JointSetPosition {
    const message = createBaseJointSetPosition();
    message.position = object.position ?? 0;
    message.velocity = object.velocity ?? 0;
    return message;
  },
};

function createBaseJointCommand(): JointCommand {
  return { jointId: 0, command: 0, setVelocity: undefined, setPosition: undefined, setTorque: undefined };
}

export const JointCommand = {
  encode(message: JointCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jointId !== 0) {
      writer.uint32(8).uint32(message.jointId);
    }
    if (message.command !== 0) {
      writer.uint32(16).int32(message.command);
    }
    if (message.setVelocity !== undefined) {
      writer.uint32(29).float(message.setVelocity);
    }
    if (message.setPosition !== undefined) {
      JointSetPosition.encode(message.setPosition, writer.uint32(34).fork()).join();
    }
    if (message.setTorque !== undefined) {
      writer.uint32(45).float(message.setTorque);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JointCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJointCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.jointId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.setVelocity = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.setPosition = JointSetPosition.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.setTorque = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JointCommand {
    return {
      jointId: isSet(object.jointId) ? globalThis.Number(object.jointId) : 0,
      command: isSet(object.command) ? jointCommandTypeFromJSON(object.command) : 0,
      setVelocity: isSet(object.setVelocity) ? globalThis.Number(object.setVelocity) : undefined,
      setPosition: isSet(object.setPosition) ? JointSetPosition.fromJSON(object.setPosition) : undefined,
      setTorque: isSet(object.setTorque) ? globalThis.Number(object.setTorque) : undefined,
    };
  },

  toJSON(message: JointCommand): unknown {
    const obj: any = {};
    if (message.jointId !== 0) {
      obj.jointId = Math.round(message.jointId);
    }
    if (message.command !== 0) {
      obj.command = jointCommandTypeToJSON(message.command);
    }
    if (message.setVelocity !== undefined) {
      obj.setVelocity = message.setVelocity;
    }
    if (message.setPosition !== undefined) {
      obj.setPosition = JointSetPosition.toJSON(message.setPosition);
    }
    if (message.setTorque !== undefined) {
      obj.setTorque = message.setTorque;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JointCommand>, I>>(base?: I): JointCommand {
    return JointCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JointCommand>, I>>(object: I): JointCommand {
    const message = createBaseJointCommand();
    message.jointId = object.jointId ?? 0;
    message.command = object.command ?? 0;
    message.setVelocity = object.setVelocity ?? undefined;
    message.setPosition = (object.setPosition !== undefined && object.setPosition !== null)
      ? JointSetPosition.fromPartial(object.setPosition)
      : undefined;
    message.setTorque = object.setTorque ?? undefined;
    return message;
  },
};

function createBaseConnectorCommand(): ConnectorCommand {
  return {
    connectorId: 0,
    command: 0,
    connectPower: undefined,
    disconnectPower: undefined,
    setDistanceMode: undefined,
  };
}

export const ConnectorCommand = {
  encode(message: ConnectorCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectorId !== 0) {
      writer.uint32(8).uint32(message.connectorId);
    }
    if (message.command !== 0) {
      writer.uint32(16).int32(message.command);
    }
    if (message.connectPower !== undefined) {
      writer.uint32(24).int32(message.connectPower);
    }
    if (message.disconnectPower !== undefined) {
      writer.uint32(32).int32(message.disconnectPower);
    }
    if (message.setDistanceMode !== undefined) {
      writer.uint32(40).int32(message.setDistanceMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectorCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectorCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.connectorId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.connectPower = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.disconnectPower = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.setDistanceMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectorCommand {
    return {
      connectorId: isSet(object.connectorId) ? globalThis.Number(object.connectorId) : 0,
      command: isSet(object.command) ? connectorCommandTypeFromJSON(object.command) : 0,
      connectPower: isSet(object.connectPower) ? connectorLineFromJSON(object.connectPower) : undefined,
      disconnectPower: isSet(object.disconnectPower) ? connectorLineFromJSON(object.disconnectPower) : undefined,
      setDistanceMode: isSet(object.setDistanceMode) ? lidarDistanceModeFromJSON(object.setDistanceMode) : undefined,
    };
  },

  toJSON(message: ConnectorCommand): unknown {
    const obj: any = {};
    if (message.connectorId !== 0) {
      obj.connectorId = Math.round(message.connectorId);
    }
    if (message.command !== 0) {
      obj.command = connectorCommandTypeToJSON(message.command);
    }
    if (message.connectPower !== undefined) {
      obj.connectPower = connectorLineToJSON(message.connectPower);
    }
    if (message.disconnectPower !== undefined) {
      obj.disconnectPower = connectorLineToJSON(message.disconnectPower);
    }
    if (message.setDistanceMode !== undefined) {
      obj.setDistanceMode = lidarDistanceModeToJSON(message.setDistanceMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectorCommand>, I>>(base?: I): ConnectorCommand {
    return ConnectorCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectorCommand>, I>>(object: I): ConnectorCommand {
    const message = createBaseConnectorCommand();
    message.connectorId = object.connectorId ?? 0;
    message.command = object.command ?? 0;
    message.connectPower = object.connectPower ?? undefined;
    message.disconnectPower = object.disconnectPower ?? undefined;
    message.setDistanceMode = object.setDistanceMode ?? undefined;
    return message;
  },
};

function createBaseMessage(): Message {
  return { message: "" };
}

export const Message = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseRofiRequest(): RofiRequest {
  return { packetId: 0, command: 0, message: undefined, device: undefined, joint: undefined, connector: undefined };
}

export const RofiRequest = {
  encode(message: RofiRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packetId !== 0) {
      writer.uint32(8).int32(message.packetId);
    }
    if (message.command !== 0) {
      writer.uint32(24).int32(message.command);
    }
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(34).fork()).join();
    }
    if (message.device !== undefined) {
      DeviceCommand.encode(message.device, writer.uint32(42).fork()).join();
    }
    if (message.joint !== undefined) {
      JointCommand.encode(message.joint, writer.uint32(50).fork()).join();
    }
    if (message.connector !== undefined) {
      ConnectorCommand.encode(message.connector, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RofiRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRofiRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.packetId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.command = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.device = DeviceCommand.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.joint = JointCommand.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.connector = ConnectorCommand.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RofiRequest {
    return {
      packetId: isSet(object.packetId) ? globalThis.Number(object.packetId) : 0,
      command: isSet(object.command) ? commandTypeRequestFromJSON(object.command) : 0,
      message: isSet(object.message) ? Message.fromJSON(object.message) : undefined,
      device: isSet(object.device) ? DeviceCommand.fromJSON(object.device) : undefined,
      joint: isSet(object.joint) ? JointCommand.fromJSON(object.joint) : undefined,
      connector: isSet(object.connector) ? ConnectorCommand.fromJSON(object.connector) : undefined,
    };
  },

  toJSON(message: RofiRequest): unknown {
    const obj: any = {};
    if (message.packetId !== 0) {
      obj.packetId = Math.round(message.packetId);
    }
    if (message.command !== 0) {
      obj.command = commandTypeRequestToJSON(message.command);
    }
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    if (message.device !== undefined) {
      obj.device = DeviceCommand.toJSON(message.device);
    }
    if (message.joint !== undefined) {
      obj.joint = JointCommand.toJSON(message.joint);
    }
    if (message.connector !== undefined) {
      obj.connector = ConnectorCommand.toJSON(message.connector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RofiRequest>, I>>(base?: I): RofiRequest {
    return RofiRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RofiRequest>, I>>(object: I): RofiRequest {
    const message = createBaseRofiRequest();
    message.packetId = object.packetId ?? 0;
    message.command = object.command ?? 0;
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    message.device = (object.device !== undefined && object.device !== null)
      ? DeviceCommand.fromPartial(object.device)
      : undefined;
    message.joint = (object.joint !== undefined && object.joint !== null)
      ? JointCommand.fromPartial(object.joint)
      : undefined;
    message.connector = (object.connector !== undefined && object.connector !== null)
      ? ConnectorCommand.fromPartial(object.connector)
      : undefined;
    return message;
  },
};

function createBaseRofiResponse(): RofiResponse {
  return { packetId: 0, success: 0, message: "" };
}

export const RofiResponse = {
  encode(message: RofiResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packetId !== 0) {
      writer.uint32(8).int32(message.packetId);
    }
    if (message.success !== 0) {
      writer.uint32(24).int32(message.success);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RofiResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRofiResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.packetId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.success = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RofiResponse {
    return {
      packetId: isSet(object.packetId) ? globalThis.Number(object.packetId) : 0,
      success: isSet(object.success) ? globalThis.Number(object.success) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RofiResponse): unknown {
    const obj: any = {};
    if (message.packetId !== 0) {
      obj.packetId = Math.round(message.packetId);
    }
    if (message.success !== 0) {
      obj.success = Math.round(message.success);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RofiResponse>, I>>(base?: I): RofiResponse {
    return RofiResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RofiResponse>, I>>(object: I): RofiResponse {
    const message = createBaseRofiResponse();
    message.packetId = object.packetId ?? 0;
    message.success = object.success ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
